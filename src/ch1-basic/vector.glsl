precision highp float;

void main(void) {
	// すべて vec4(1.0, 2.0, 3.0, 4.0) を作成
    // vec2, vec3 でも同様
	vec4(1.0, 2.0, 3.0, 4.0);
	vec4(vec2(1.0, 2.0), 3.0, 4.0);
	vec4(vec3(1.0, 2.0, 3.0), 4.0);
	vec4(vec2(1.0, 2.0), vec2(3.0, 4.0));
	vec4(1.0, vec2(2.0, 3.0), 4.0);
	vec4(1.0, vec3(1.0, 2.0, 3.0));
	vec4(vec4(1.0, 2.0, 3.0, 4.0));
	
	// 値の取得 (Swizzle演算子という, すべての組み合わせではない)
	// vec2, vec3 でも同様
	vec4 v = vec4(1.0, 2.0, 3.0, 4.0);
	v.x; // = 1.0
	v.y; // = 2.0
	v.z; // = 3.0
	v.w; // = 4.0
	v.xy; // = vec2(1.0, 2.0)
	v.xx; // = vec2(1.0, 1.0)
	v.yx; // = vec2(2.0, 1.0)
	v.xz; // = vec2(1.0, 3.0)
	v.xyz; // = vec3(1.0, 2.0, 3.0)
	v.xyy; // = vec3(1.0, 2.0, 2.0)
	v.r; // 1.0
	v.g; // 2.0
	v.b; // 3.0
	v.a; // 4.0
	v.rgb; // vec3(1.0, 2.0, 3.0)

	// スカラーとの演算
	// vec2, vec3 でも同様
	vec4 v = vec4(1.0, 2.0, 3.0, 4.0)
	v + 1.0; // = vec4(2.0, 3.0, 4.0, 5.0)
	v - 1.0; // = vec4(0.0, 1.0, 2.0, 3.0)
	v * 2.0; // = vec4(2.0, 4.0, 6.0, 8.0)
	v / 2.0; // = vec4(0.5, 1.0, 1.5, 2.0)
	1.0 + v; // = vec4(2.0, 3.0, 4.0, 5.0)
	1.0 - v; // = vec4(0.0, -1.0, -2.0, -3.0)
	2.0 * v; // = vec4(2.0, 4.0, 6.0, 8.0)
	2.0 / v; // = vec4(2.0, 1.0, 0.666..., 0.5)
	
	// ベクトル同士の演算
	// vec2, vec3 でも同様
	vec4 v1 = vec4(1.0, 2.0, 3.0, 4.0);
	vec4 v2 = vec4(5.0, 6.0, 7.0, 8.0);
	v1 + v2; // = vec4(6.0, 8.0, 10.0, 12.0)
	v1 - v2; // = vec4(-4.0, -4.0, -4.0, -4.0)
	v1 * v2; // = vec4(5.0, 12.0, 21.0, 32.0)
	v1 / v2; // = vec4(0.2, 0.333..., 0.429..., 0.5)
	
	//異なる大きさのベクトル同士では演算できない
	vec2(1.0, 2.0) + vec3(1.0, 2.0, 3.0); // これはエラーになる

	gl_FragColor = vec4(vec3(0.0), 1.0);
}